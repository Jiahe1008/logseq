- [[UL2]]
- ### 1. 缺页中断发生时，CPU 到底停在了哪里？
  
  缺页中断属于异常（Exception）里的 **Fault（故障）**。它和一般的“中断”有个巨大的区别：
- **普通中断**：执行完指令 A，去处理中断，回来执行指令 B。
- **缺页中断**：执行指令 A 时发现没内存，去处理异常，回来**重新执行指令 A**。
  
  **关键点**：CPU 必须具备“断点重执行”的能力。比如 `MOV EAX, [某个缺页地址]`，这条指令在缺页时只执行了一半，操作系统把页面从磁盘搬回内存后，必须让 CPU 回到这条指令的开头重新来一遍。
  
  ---
- ### 2. 操作系统是怎么知道“缺哪页”的？
  
  你可能想过：当页表里的 P 位是 0 时，CPU 报错了。但操作系统怎么知道程序刚才想访问哪个地址？
  
  这里要提到一个功不可没的**寄存器：CR2**。
- 当 CPU 触发缺页中断时，它会自动把引起异常的那个**线性地址**（那个它没能转换成功的地址）塞进 **CR2 寄存器**。
- OS 的缺页处理程序第一件事就是去读 CR2，这样它才知道该去硬盘的哪个“交换分区”搬救兵。
  
  ---
- ### 3. “合法”缺页 vs “非法”缺页
  
  并不是所有的缺页中断都是为了从硬盘搬数据。OS 会在处理程序里做“判官”：
  
  | **类型** | **场景** | **处理结果** |
  | ---- | ---- | ---- |
  | **合法缺页 (Minor)** | 代码段还没加载、或者写时复制 (COW) | OS 赶紧分配物理内存，更新页表，放行。 |
  | **合法缺页 (Major)** | 内存不够了，数据在 Swap 分区（磁盘）里 | OS 启动慢速磁盘 I/O，把数据搬回来，放行。 |
  | **非法访问 (Segmentation Fault)** | 程序试图访问不属于它的地址（比如 NULL 指针） | OS 发现页表里根本没这一项记录，直接发送 `SIGSEGV`，**干掉进程**。 |
  
  ---
- ### 4. 为什么你会感觉到“卡顿”？
  
  当你切回一个很久没打开的后台软件时，电脑会“咯噔”响一下或者鼠标转圈，这就是**大规模缺页中断**在发生。
- CPU 频繁触发缺页异常。
- OS 发现物理内存满了，得先把别人家的数据踢到硬盘（Page Out）。
- 再把你要的数据从硬盘读进来（Page In）。
- 磁盘速度比内存慢 **10 万倍**，这就是你感觉到“卡”的根本原因。
  
  ---
- ### 5. 一个有趣的问题：页表本身缺页了怎么办？
  
  这是个套娃问题。如果页目录指向的那个“页表”本身也不在内存里呢？
- 在多级页表架构下，这确实会发生。
- 结果就是：**多级缺页**。OS 会逐级解决，先加载页目录指向的页表，再加载页表指向的物理页。
  
  ---
- ### 总结
  
  缺页中断本质上是操作系统在**“拆东墙补西墙”**：它利用极速的页表查询和慢速的磁盘存储，给程序营造了一个“我有无穷大内存”的幻觉。
-