-
	- 核心态系统组件
		- 执行体
		- 内核
		- 设备驱动程序
		- 硬件抽象层HAL
- 系统机制
	- 陷阱调度
		- 中断
		- APC
		- DPC
	- 执行体对象管理器
	  id:: 694b4cf2-bc8a-45ad-9ecf-927ee60bd6d2
	- 同步
	- 本地过程调用
- ### 执行体线程块
- ### 线程的状态
- 题目
	- ### 第一；关：地址翻译
	  
	  假设在一个 32 位 x86 系统中，`CR3` 寄存器的值为 `0x12000000`（这是页目录表的物理基地址）。
	  现在有一个线性地址：`0x8053A2F0`。
	- 请将其拆分为 **PDE Index**、**PTE Index** 和 **Offset**（十六进制或十进制均可）。
	- 如果在页目录表中，索引为该 PDE Index 的项（PDE）内容为 `0x15000063`，那么对应的**页表（Page Table）**的物理地址是什么？
	- 如果对应的 PTE 内容为 `0x18000063`，最终的物理地址是多少？
		- ####  *在 x86 分页机制中，PDE 和 PTE 的低 12 位是状态位（比如你看到的 `0x63` 代表该页存在、可读写、用户态可访问等），高 20 位 才是真正的物理地址基址。*
	-
	- ---
	-
	- ### 第二关：自映射（Self-Mapping）的诅咒
	  
	  你刚才提到了“左移 10 位得到页目录表虚地址”。
	- **问题：** 假设 Windows 内核通过自映射机制，将页目录表映射到了虚拟地址 `$0xC0300000$`。
	- 那么，当内核想要修改线性地址 `$0x8053A2F0$` 对应的**页表项（PTE）时，它应该访问哪一个虚拟地址**？（提示：利用缩放关系，PTE 的虚拟地址也是通过一套公式算出来的）。
	  
	  ---
	- ### 第三关：DPC 的生死禁令
	  
	  你在写一个网络驱动程序。在你的 **DPC 例程**（运行在 `DISPATCH_LEVEL`）中，你写了下面这段逻辑：
	  
	  <!----><!----><!----><!----><!----><!----><!---->
	  
	  C
	  
	  <!----><!---->
	  
	  <!---->
	  
	  <!---->
	  
	  ```
	  void MyDpcRoutine(...) {
	    // ... 处理了一些数据 ...
	    KeWaitForSingleObject(&MyMutex, Executive, KernelMode, FALSE, NULL); 
	    // ... 修改共享资源 ...
	    KeReleaseMutex(&MyMutex, FALSE);
	  }
	  ```
	  
	  <!---->
	  
	  <!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!---->
	- **问题：** 这段代码能通过测试吗？如果不能，会发生什么？为什么？（结合你之前问的“执行体同步”来思考）。
	  
	  ---
	- ### 第四关：自旋锁（Spinlock）的智商税
	  
	  在一个**单核（Single Core）**处理器上，如果你编写的代码在拿不到自旋锁时原地“自旋”：
	- **问题：** 如果这个系统**不支持抢占（Non-preemptive）**，会发生什么后果？如果**支持抢占（Preemptive）**，性能表现会好吗？
	  
	  ---
	- ### 第五关：亲和性（Affinity）实战
	  
	  如果你有一个计算密集型的算法（比如 3D 渲染或加密），你需要开启 4 个线程。
	- **场景：** 你的 CPU 有 4 个物理核心，每个核心支持 2 个逻辑线程（超线程）。
	- **问题：** 为了获得最高性能，你会如何设置这 4 个线程的**亲和性掩码（Affinity Mask）**？是把它们全塞进同一个物理核心的逻辑线程里，还是分散开？为什么？
-